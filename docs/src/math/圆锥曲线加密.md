# pytorch_ddl

```python
print("hello world")

import matplotlib.pyplot as plt
plt.rcParams['font.sans-serif'] = ['SimHei'] # 设置黑体为默认字体
plt.rcParams['axes.unicode_minus'] = False # 解决负号显示问题
```

**Output:**

```
hello world

```

```python
# 常量定义
KEY_BITS = 256
```

```python
import numpy as np
from sympy import isprime
import secrets


def Ep(a, b, p):
    a = a % p
    b = b % p
    discriminant = (4 * a**3 + 27 * b**2) % p

    if discriminant == 0:
        raise ValueError(f"曲线退化！判别式 ≡ 0 mod {p}")
    
    if not isprime(p):
        raise ValueError(f"{p} 不是素数")
    
    return (a, b, p)


class Point:
    def __init__(self, x, y, curve):
        self.x = x
        self.y = y
        self.curve = curve  # (a, b, p)
        self.is_infinity = (x is None and y is None)

    def __eq__(self, other):
        if self.is_infinity and other.is_infinity:
            return True
        return (self.x == other.x and self.y == other.y and self.curve == other.curve)

    def __repr__(self):
        return f"Point({self.x}, {self.y})" if not self.is_infinity else "Point(∞)"
    
    def __add__(self, other):
        if isinstance(other, int):  # 支持与常数相加
            return Point(self.x + other if self.x is not None else None,
                         self.y + other if self.y is not None else None,
                         self.curve)
        elif isinstance(other, Point):  # 点相加
            if self.curve != other.curve:
                raise ValueError("Points are not on the same curve")
            x = self.x + other.x if (self.x is not None and other.x is not None) else None
            y = self.y + other.y if (self.y is not None and other.y is not None) else None
            return Point(x, y, self.curve)
        else:
            raise TypeError(f"Unsupported operand type(s) for +: 'Point' and '{type(other).__name__}'")
```

```python
def EC_point_add(P, Q):
    if P.is_infinity:
        return Q
    if Q.is_infinity:
        return P
    
    a, b, p = P.curve
    x1, y1 = P.x, P.y
    x2, y2 = Q.x, Q.y

    if P == Q:
        if y1 == 0:  #切线是垂直的，结果是无穷远点
            return Point(None, None, P.curve)
        numerator = (3 * x1 * x1 + a) % p
        denominator = (2 * y1) % p
    else:
        if x1 == x2: # x1=x2，则两点在同一条垂直线上，结果是无穷远点
            return Point(None, None, P.curve)
        numerator = (y2 - y1) % p
        denominator = (x2 - x1) % p

    inv_denominator = pow(denominator, -1, p)
    λ = (numerator * inv_denominator) % p

    x3 = (λ * λ - x1 - x2) % p
    y3 = (λ * (x1 - x3) - y1) % p

    return Point(x3, y3, P.curve)
```

```python
def scalar_mult(k, P):
    """
    计算 k * P，使用 Double-and-Add 算法
    :param k: 整数（标量）
    :param P: 椭圆曲线上的点
    :return: k * P
    """
    if k == 0:
        return Point(None, None, P.curve)  # 返回无穷远点
    
    Q = Point(None, None, P.curve)  # 初始化为无穷远点
    R = P  # 临时变量
    
    while k > 0:
        if k % 2 == 1:  # 如果当前位是 1
            Q = EC_point_add(Q, R)  # Q += R
        R = EC_point_add(R, R)  # R = 2R（点加倍）
        k = k // 2  # 右移一位
    
    return Q
```

```python
def scalar_mult_montgomery(k, P):
    """
    计算 k * P，使用 Montgomery Ladder 算法防御侧信道攻击
    :param k: 整数（标量）
    :param P: 椭圆曲线上的点
    :return: k * P
    """
    R0 = Point(None, None, P.curve)  # 初始化为无穷远点
    R1 = P
    
    for bit in bin(k)[2:]:  # 遍历 k 的二进制位
        if bit == '0':
            R1 = EC_point_add(R0, R1)
            R0 = EC_point_add(R0, R0)
        else:
            R0 = EC_point_add(R0, R1)
            R1 = EC_point_add(R1, R1)
    
    return R0

```

```python
import secrets
import hashlib

class SECP256K1:
    def __init__(self):
        # 椭圆曲线参数 y² = x³ + a*x + b mod p
        self.a = 0
        self.b = 7
        self.p = 2**256 - 2**32 - 977  # 域素数

        # 定义曲线
        self.curve = Ep(self.a, self.b, self.p)

        # 基点 G
        self.Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
        self.Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
        self.G = Point(self.Gx, self.Gy, self.curve)

        # 曲线阶数
        self.n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

        self.private_key = None
        self.public_key = None

    def generate_keypair(self, private_key=None):
        """
        生成安全的椭圆曲线数字签名算法(ECDSA)密钥对

        参数:
            private_key: 可选，指定私钥(用于确定性密钥生成)。如果为None则随机生成

        返回:
            元组(private_key, public_key): 私钥(整数)和公钥(Point对象)

        示例:
            >>> curve = SECP256K1()
            >>> priv, pub = curve.generate_keypair()
            >>> priv, pub = curve.generate_keypair(0x1)  # 使用指定私钥
        """

        if private_key is None:
            self.private_key = secrets.randbelow(self.n - 1) + 1  # 1 <= d < n
        else:
            self.private_key = private_key % self.n
            if self.private_key == 0:
                self.private_key = 1

        self.public_key = scalar_mult(self.private_key, self.G)
        return self.private_key, self.public_key

    def ECIES_encode(self, message, public_key):
        """ECIES 加密算法

        Args:
            message: 要加密的消息，可以是整数或字符串
            public_key: 接收者的公钥

        Returns:
            密文元组 (rG, M + rQ)
        """

        M = int(message)
        r = secrets.randbelow(self.n - 1) + 1  # 1 <= r < n
        rG = scalar_mult(r, self.G)
        rQ = scalar_mult(r, public_key)

        C = (rG,rQ+M)
        return C

    def ECIES_decode(self, C):
        """ECIES 解密算法

        Args:
            ciphertext: 密文元组 (rG, M + rQ)

        Returns:
            解密后的消息整数
        """
        rG = C[0]
        M_and_rQ = C[1]

        rdG = scalar_mult(self.private_key, rG)
        message = M_and_rQ.x - rdG.x
        return message

    def ECDSA_sign(self, message, private_key=None):
        """
        使用ECDSA算法对消息进行签名
        参数:
            message: 要签名的消息字符串
            private_key: 可选，指定私钥。如果为None则使用实例的私钥
        返回:
            签名元组(r, s)
        异常:
            ValueError: 如果私钥无效或签名过程中出现错误
        """

        # 参数验证
        if private_key is None:
            if self.private_key is None:
                raise ValueError("未提供私钥且实例未生成私钥")
            private_key = self.private_key

        if not (1 <= private_key < self.n):
            raise ValueError(f"私钥必须在1到{self.n-1}之间")

        # 计算消息哈希并转换为整数
        message_hash = hashlib.sha256(message.encode()).hexdigest()
        message_hash_int = int(message_hash, 16) % self.n

        r, s = 0, 0
        # 生成有效的签名
        while r == 0 or s == 0:
            # 生成临时密钥k
            k = secrets.randbelow(self.n - 1) + 1  # 1 <= k < n

            # 计算R = k*G
            R = scalar_mult(k, self.G)
            r = R.x % self.n

            # 计算s
            if r == 0:
                continue  # 重新生成k

            try:
                k_inv = pow(k, -1, self.n)  # 计算k的模逆
            except ValueError:
                continue  # 如果k没有逆元，重新生成k

            s = ((message_hash_int + private_key * r) * k_inv) % self.n

        return (r, s)

    def ECDSA_verify(self, message, signature, public_key):
        """
        验证ECDSA签名

        参数:
            message: 原始消息字符串
            signature: 签名元组(r, s)
            public_key: 公钥点对象

        返回:
            bool: 签名是否有效
        """
        # 1. 验证签名格式
        if len(signature) != 2:
            raise ValueError("签名必须是(r, s)元组")

        r, s = signature

        # 2. 验证r和s的范围
        if not (1 <= r < self.n and 1 <= s < self.n):
            return False

        # 3. 计算消息哈希并转换为整数
        message_hash = hashlib.sha256(message.encode()).hexdigest()
        message_hash_int = int(message_hash, 16) % self.n

        # 4. 计算s的模逆
        s_inv = pow(s, -1, self.n)

        # 5. 计算中间值
        u1 = (message_hash_int * s_inv) % self.n
        u2 = (r * s_inv) % self.n

        # 6. 计算点P = u1*G + u2*Q
        u1G = scalar_mult(u1, self.G)
        u2Q = scalar_mult(u2, public_key)
        P = EC_point_add(u1G, u2Q)

        # 7. 验证签名
        if P.is_infinity:
            return False

        return (P.x % self.n) == r
```

```python
mySECP256K1=SECP256K1()
```

```python
d,Q=mySECP256K1.generate_keypair()
print(f"私钥  :",d)
print("公钥  :",Q)
```

**Output:**

```
私钥  : 98535816174817037292425042047268346075263458068093621936779519087802389893362
公钥  : Point(46995973741845879010719782918597029490709283288366917464339733751702193990270, 105996729303902000947545635897860615206275330773213865830256324458113579195560)

```

```python
# 编码测试
Message=10001
encode = mySECP256K1.ECIES_encode(Message,mySECP256K1.public_key)
print(encode)
print(len(encode))
```

**Output:**

```
(Point(109492706218755500709462683678788303809444010740590761262570997968121833517778, 50731745258315302772421608987668682910075672784455164284886206145271865973519), Point(105473797442323193325301781341525705894281861550318075865416688109431079945019, 7869759561862237548209866701330177713846573659046970045672160743002782799625))
2

```

```python
# 解码测试
decode = mySECP256K1.ECIES_decode(encode)
print("解码信息",decode)
```

**Output:**

```
解码信息 10001

```

```python
# 签名测试
message ="这是一个非常好的开端"

signature=mySECP256K1.ECDSA_sign(message)

print("signature  :",signature)
```

**Output:**

```
signature  : (22511923418774237114152692512993696658505313162286950322391972870323761877075, 110006805957302925654548943433838941036190691839912818294709589743044470824612)

```

```python
message1="这是一个非常好的开1端"
flag=mySECP256K1.ECDSA_verify(message1,signature,mySECP256K1.public_key)
print("flag  :",flag)
```

**Output:**

```
flag  : False

```

```python

```

